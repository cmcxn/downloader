
迅雷开放平台
1.初始化SDK
调用xl_dl_init，初始化SDK，以进行后续API调用
2.生成登录token,并登录SDK基于安全考虑，由业务服务器生成“登录token”’。并调用xl_dl_login，登录SDK
3.创建下载任务
调用xl_dl_create_p2sp_task，创建下载任务，管理文件下载
4.启动下载任务
调用xl_dl_start_task启动下载任务，开始下载文件
5.定时检查下载任务状态
业务侧调用xl_dl_get_task_state，检测下载任务状态，等待任务结束(成功或失败)
6.完成下载，释放SDK资源
调用xl_dl_uninit，在不再需要使用SDK时，释放SDK资源


xl_dl_init
说明:
初始化 SDK。

语法：
int32_t xl_dl_init(const xl_dl_init_param* param)

参数:
[in]param: 指向 struct xl_dl_init_param_t 结构体的指针。

struct xl_dl_init_param_t
{
 const char* app_id; // 应用 ID,控制台创建应用时生成的 app_id
 const char* app_version; // 应用版本号
 const char* cfg_path; // 配置信息及任务信息保存路径, utf8 编码
 uint8_t save_tasks; // 是否保存任务信息，1：保存 0：不保存
}

返回值:
成功返回 0，失败返回相应错误码。

备注:
需确保 cfg_path 对应的路径存在且可写，SDK 在此目录存储配置信息和任务信息。

常见错误码：
XL_DL_ERROR_FILE_NOT_EXIST（9504）需要检查cfg_path给定路径是否存在且可写。

xl_dl_uninit
说明:
反初始化。

语法:
int32_t xl_dl_uninit()

参数:
无。

返回值:
成功返回 0，失败返回相应错误码。

xl_dl_login
说明:
用于登录。

语法:
int32_t xl_dl_login(const char* login_token, char* session_id);

参数:
[in]login_token: 登录 token。

[out]session_id: 用于保存返回的 session_id 的缓冲区，至少需要 4096 字节。

返回值:
成功返回 0，失败返回相应错误码。
xl_dl_get_unfinished_tasks
说明:
获取未完成任务 ID，包括已失败的任务。

语法:
int32_t xl_dl_get_unfinished_tasks(uint64_t* task_id_array, uint32_t* count)

例:

uint32_t task_count = 0;
auto code = xl_dl_get_unfinished_tasks(NULL, &task_count);

uint64_t* task_id_array = new uint64_t[task_count];
code = xl_dl_get_unfinished_tasks(task_id_array, &task_count);

参数:
[out]task_id_array: 用于保存任务 ID 的缓冲区，当 task_id_array 为 NULL 时，SDK 通过 count 指向的值返回任务的数量。

[in, out]count: count 指向的值应设置为 task_id_array 所能容纳的任务数量，函数返回时，SDK 将 count 指向的值设置为已拷贝到 task_id_array 中的任务 ID 数量。

返回值:
成功返回 0，失败返回相应错误码。

xl_dl_get_finished_tasks
说明:
获取已完成任务 ID。

语法:
int32_t xl_dl_get_finished_tasks(uint64_t* task_id_array, uint32_t* count)

例:

uint32_t task_count = 0;
auto code = xl_dl_get_finished_tasks(NULL, &task_count);

uint64_t* task_id_array = new uint64_t[task_count];
code = xl_dl_get_finished_tasks(task_id_array, &task_count);

参数:
[out] task_id_array: 用于保存任务 ID 的缓冲区，当 task_id_array 为 NULL 时，SDK 通过 count 指向的值返回任务的数量。

[in, out] count: 调用者应将 count 指向的值设置为 task_id_array 所能容纳的任务数量，函数返回时，SDK 将 count 指向的值设置为已拷贝到 task_id_array 中的任务 ID 数量。

返回值:
成功返回 0，失败返回相应错误码。

xl_dl_create_p2sp_task
说明:
创建 p2sp 下载任务。

语法:
int32_t xl_dl_create_p2sp_task(const xl_dl_create_p2sp_info* create_info, uint64_t* task_id)

参数:
[in]create_info: 指向 struct xl_dl_create_p2sp_info_t 结构体的指针。

struct xl_dl_create_p2sp_info_t {
 const char* save_path; // 文件保存路径, utf8 编码
 const char* save_name; // 文件名称, utf8 编码
 const char* url; // 下载 URL, utf8 编码
}

[in, out]task_id: 任务创建成功后任务 ID 被设置到该指针指向的变量中。

返回值:
成功返回 0，失败返回相应错误码。

xl_dl_create_batch_task
说明:
创建批量 p2sp 下载任务。

语法:
int32_t xl_dl_create_batch_task(const xl_dl_create_batch_info* create_info, uint64_t* task_id)

参数:
[in] create_info: 指向 xl_dl_create_batch_info 结构体的指针，包含批量任务配置信息。

struct xl_dl_create_batch_info_t {
 const char* task_name; // 任务名称, utf8 编码
 uint32_t max_concurrent; // 最大并发下载数，默认值为 20
 xl_dl_files_info* batch_files; // 批量文件信息
};

struct xl_dl_files_info_t {
 uint32_t file_count; // 文件数量 (需确保 file_list 数组大小与 file_count 一致)
 xl_dl_file_item* file_list; // 文件列表（数组）
};

struct xl_dl_file_item_t {
 const char* url; // 下载 URL（必填）
 const char* save_path; // 文件存储路径（必填）
 const char* save_name; // 文件名（必填）
 const char* file_hash; // 文件哈希值（可选，目前留作扩展用途）
};

[in, out]task_id: 任务创建成功后任务 ID 被设置到该指针指向的变量中。

返回值:
成功返回 0，失败返回相应错误码。

xl_dl_start_task
说明:
启动任务。

语法:
int32_t xl_dl_start_task(uint64_t task_id);

参数:
[in]task_id:任务 ID。

返回值:
成功返回 0，失败返回相应错误码。

xl_dl_stop_task
说明:
停止任务。

语法:
int32_t xl_dl_stop_task(uint64_t task_id);

参数:
[in]task_id: 任务 ID。

返回值:
成功返回 0，失败返回相应错误码。

xl_dl_delete_task
说明:
删除任务。

语法:
int32_t xl_dl_delete_task(uint64_t task_id, uint8_t delete_file);

参数:
[in]task_id: 任务 ID。

[in]delete_file: 是否删除已下载的文件 1：删除 0：不删除。

返回值:
成功返回 0，失败返回相应错误码。

xl_dl_get_task_state
说明:
查询任务状态。

语法:
int32_t xl_dl_get_task_state(uint64_t task_id, xl_dl_task_state* state);

参数:
[in]task_id: 任务 ID。

[out]state: 指向 struct xl_dl_task_state_t 结构体的指针。

struct xl_dl_task_state_t {
 uint64_t speed; //任务下载速度，Bytes/s
 uint64_t total_size; //文件总字节数
 uint64_t downloaded_size; //已下载总字节数
 uint8_t state_code; //任务状态码
 uint32_t task_err_code; //任务错误码
 uint32_t task_token_err; //token 错误码
}

返回值:
成功返回 0，失败返回相应错误码。

备注:
任务状态码说明：
XL_DL_TASK_STATUS_UNKOWN = 0 //未知
XL_DL_TASK_STATUS_START_WAITING = 3 //等待启动
XL_DL_TASK_STATUS_START_PENDING = 4 //正在启动
XL_DL_TASK_STATUS_STARTED = 5 //正在运行
XL_DL_TASK_STATUS_STOP_PENDING = 6 //正在停止
XL_DL_TASK_STATUS_STOPED = 7 //已停止
XL_DL_TASK_STATUS_SUCCEEDED = 8 //任务已完成
XL_DL_TASK_STATUS_FAILED = 9 //任务失败


xl_dl_get_task_info
说明:
获取任务信息。

语法:
int32_t xl_dl_get_task_info(uint64_t task_id, const char* info_name, void* buff, uint32_t* buff_len);

参数:
[in]task_id: 任务 ID。

[in]info_name: 信息名称。

info_name	描述	输出类型（buff）	示例
url	获取任务 URL	string	uint32_t len = 0;
auto code = xl_dl_get_task_info(task_id, “url”, NULL, &len)

char* url_buff = new char[len];
code = xl_dl_get_task_info(task_id, “url”, url_buff, &len);
save_path	获取文件保存路径	string	uint32_t len = 0;
auto code = xl_dl_get_task_info(task_id, “save_path”, NULL, &len)

char* path_buff = new char[len];
code = xl_dl_get_task_info(task_id, “save_path”, path_buff, &len);
save_name	获取文件保存名称	string	uint32_t len = 0;
auto code = xl_dl_get_task_info(task_id, “save_name”, NULL, &len)

char* name_buff = new char[len];
code = xl_dl_get_task_info(task_id, “save_name”, name_buff, &len);
traffic	获取任务流量信息	struct	struct xl_dl_task_traffic_info_t {
 uint64_t origin_size; //从原始 url 下载字节数
 uint64_t p2p_size; //通过 P2P 下载的字节数
 uint64_t p2s_size; //通过 P2S 下载的字节数
 uint64_t dcdn_size; //保留
}
xl_dl_task_traffic_info info;
uint32_t len = sizeof(info);
code = xl_dl_get_task_info(task_id, “traffic”, &info, &len);
creation_time	获取任务创建时间	uint64	uint64_t ts = 0;
uint32_t sz = sizeof(ts);
code = xl_dl_get_task_info(task_id, “creation_time”, &ts, &sz);
completion_time	获取任务完成时间	uint64	uint64_t ts = 0;
uint32_t sz = sizeof(ts);
code = xl_dl_get_task_info(task_id, “completion_time”, &ts, &sz);
[out]buff: 缓冲区地址，当 buff 为 NULL 时，SDK 通过 buff_len 指向的值返回所需要的缓冲区大小。

[in, out]buff_len: 缓冲区大小，该参数所指向的值应设置为 buff 缓存区大小，函数返回时该参数所指向的值会被 SDK 设置为已拷贝字节数。

返回值:
成功返回 0，失败返回相应错误码。

xl_dl_set_concurrent_task_count
说明:
设置最大同时进行的下载任务数，默认 10。

语法:
int32_t xl_dl_set_concurrent_task_count(uint32_t count);

参数:
[in]count: 任务数量。

返回值:
成功返回 0，失败返回相应错误码。

xl_dl_set_download_speed_limit
说明:
设置下载限速，默认不限速。

语法:
int32_t xl_dl_set_download_speed_limit(uint32_t speed);

参数:
[in]speed: 速度，KB/秒，UINT32_MAX 表示不限速，最小限速值 32KB。

返回值:
成功返回 0，失败返回相应错误码。

xl_dl_set_upload_switch
说明:
设置是否开启 P2P 上传，默认不开启，设置优先级：API调用 > 控制台设置。

语法:
int32_t xl_dl_set_upload_switch(uint32_t upload_switch)

参数:
[in]upload_switch: 1: 开启上传，0: 不开启上传。

返回值:
成功返回 0，失败返回相应错误码。

xl_dl_set_upload_speed_limit
说明:
设置上传限速，默认不限速，设置优先级：API 调用 > 控制台设置。

语法:
int32_t xl_dl_set_upload_speed_limit(uint32_t speed)

参数:
[in]speed: 速度 KB/秒，UINT32_MAX 表示不限速，最小限速值 16KB。

返回值:
成功返回 0，失败返回相应错误码。

xl_dl_set_http_header
说明:
该接口用于为下载请求设置 HTTP 头部信息。
当下载服务器要求请求中包含特定的 HTTP 头部字段（如 Referer）时，开发者可调用此接口为指定的下载任务设置相应的 HTTP 头部键值对。

语法:
int32_t xl_dl_set_http_header(uint64_t task_id, const char* header_name, const char* header_value)

示例：
// 创建任务
uint64_t task_id = 0;
code = xl_dl_create_p2sp_task(&create_info, &task_id);

// 请务必在 xl_dl_start_task 前设置 http header
code = xl_dl_set_http_header(task_id, “Referer”, “http://www.xunlei.com/”)

// 开始任务
code = xl_dl_start_task(task_id);

参数:
[in]task_id: 指定需要设置 HTTP 头部信息的下载任务 ID。
[in]header_name：要设置的 HTTP 头部字段的键名，例如 Referer、User-Agent 等。
[in]header_value：对应 HTTP 头部字段键名的值，即该头部字段的具体内容。（ header_value 务必遵循 HTTP 的相应规范要求，例如当 header_name 为 Referer 时，其所对应的值应为合法合规的 URI（统一资源标识符），以此确保所设头部信息的有效性 ）

返回值:
成功返回 0，失败返回相应错误码

xl_dl_version
说明:
查询 sdk 版本号。

语法:
int32_t xl_dl_version(char* buff, uint32_t* buff_len)

例:

char version[128] = { 0 };
uint32_t version_len = sizeof(version);
auto code = xl_dl_version(version, &version_len);

参数:
[out]buff: 用于存储版本字符串的缓冲区，当 buff 为 NULL 时，SDK 通过 buff_len 指向的值返回所需要的缓冲区大小（不包括终止 null 字符）。

[in, out]buff_len: 该参数所指向的值应设置为 buff 缓存区大小，函数返回时该参数所指向的值会被 SDK 设置为已拷贝字节数（注: 不拷贝字符串终止 null 字符)。

返回值:
成功返回 0，失败返回相应错误码。

错误码

    XL_DL_ERROR_SUCCESS                         = 0,
    XL_DL_ERROR_FAILED                          = 1,
    XL_DL_ERROR_ALREADY_INIT                    = 9101,
    XL_DL_ERROR_SDK_NOT_INIT                    = 9102,
    XL_DL_ERROR_TASK_ALREADY_EXIST              = 9103,
    XL_DL_ERROR_TASK_NOT_EXIST                  = 9104,
    XL_DL_ERROR_TASK_ALREADY_STOPPED            = 9105,
    XL_DL_ERROR_TASK_ALREADY_RUNNING            = 9106,
    XL_DL_ERROR_TASK_NOT_START                  = 9107,
    XL_DL_ERROR_TASK_STILL_RUNNING              = 9108,
    XL_DL_ERROR_FILE_EXISTED                    = 9109,
    XL_DL_ERROR_DISK_FULL                       = 9110,
    XL_DL_ERROR_TOO_MUCH_TASK                   = 9111,
    XL_DL_ERROR_PARAM_ERROR                     = 9112,
    XL_DL_ERROR_SCHEMA_NOT_SUPPORT              = 9113,
    XL_DL_ERROR_DYNAMIC_PARAM_FAIL              = 9114,
    XL_DL_ERROR_CONTINUE_NO_NAME                = 9115,
    XL_DL_ERROR_APPNAME_APPKEY_ERROR            = 9116,
    XL_DL_ERROR_CREATE_THREAD_ERROR             = 9117,
    XL_DL_ERROR_TASK_FINISH                     = 9118,
    XL_DL_ERROR_TASK_NOT_RUNNING                = 9119,
    XL_DL_ERROR_TASK_NOT_IDLE                   = 9120,
    XL_DL_ERROR_TASK_TYPE_NOT_SUPPORT           = 9121,
    XL_DL_ERROR_ADD_RESOURCE_ERROR              = 9122,
    XL_DL_ERROR_FUNCTION_NOT_SUPPORT            = 9123,
    XL_DL_ERROR_ALREADY_HAS_FILENAME            = 9124,
    XL_DL_ERROR_FILE_NAME_TOO_LONG              = 9125,
    XL_DL_ERROR_ONE_PATH_LEVEL_NAME_TOO_LONG    = 9126,
    XL_DL_ERROR_FULL_PATH_NAME_TOO_LONG         = 9127,
    XL_DL_ERROR_FULL_PATH_NAME_OCCUPIED         = 9128,
    XL_DL_ERROR_TASK_NO_FILE_NAME               = 9129,
    XL_DL_ERROR_NOT_WIFI_MODE                   = 9130,
    XL_DL_ERROR_SPEED_LIMIT_TO_SMALL            = 9131,
    XL_DL_ERROR_TASK_CONTROL_STRATEGY           = 9501,
    XL_DL_ERROR_URL_IS_TOO_LONG                 = 9502,
    XL_DL_ERROR_FILE_DELETE_FAIL                = 9503,
    XL_DL_ERROR_FILE_NOT_EXIST                  = 9504,
    XL_DL_ERROR_INFO_NAME_NOT_SUPPORT           = 9505,
    XL_DL_ERROR_MEMORY_TOO_SMALL                = 9601,
    XL_DL_ERROR_AUTH_TOKEN_VERIFY_FAILED        = 9602,
    XL_DL_ERROR_AUTH_SCOPE_VERIFY_FAILED        = 9603,
    XL_DL_ERROR_AUTH_SESSION_ID_VERIFY_FAILED   = 9604,
    XL_DL_ERROR_AUTH_SESSION_ID_EXPIRED         = 9605,
    XL_DL_ERROR_AUTH_RES_HAS_NO_QUOTA           = 9606,
    XL_DL_ERROR_INSUFFICIENT_DISK_SPACE         = 111085,
    XL_DL_ERROR_OPEN_FILE_ERR                   = 111128,
    XL_DL_ERROR_NO_DATA_PIPE                    = 111136,
    XL_DL_ERROR_RESTRICTION                     = 111151,
    XL_DL_ERROR_ACCOUNT_EXCEPTION               = 111152,
    XL_DL_ERROR_RESTRICTION_AREA                = 111153,
    XL_DL_ERROR_COPYRIGHT_BLOCKING              = 111154,
    XL_DL_ERROR_TYPE2_BLOCKING                  = 111155,
    XL_DL_ERROR_TYPE3_BLOCKING                  = 111156,
    XL_DL_ERROR_LONG_TIME_NO_RECV_DATA          = 111176,
    XL_DL_ERROR_TIME_OUT                        = 119212,
    XL_DL_ERROR_TASK_STATUS_ERR                 = 999999,
